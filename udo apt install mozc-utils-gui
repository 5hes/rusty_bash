[1mdiff --git a/Cargo.toml b/Cargo.toml[m
[1mindex da54bd61..4046c50f 100644[m
[1m--- a/Cargo.toml[m
[1m+++ b/Cargo.toml[m
[36m@@ -1,15 +1,16 @@[m
 [package][m
 name = "sush"[m
[31m-version = "2025.3.0"[m
[32m+[m[32mversion = "2025.6.9"[m
 edition = "2021"[m
 [m
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[m
 [m
 [dependencies][m
[31m-nix = { version = "0.28.0", features = ["fs", "process", "signal", "term", "user", "time"]}[m
[32m+[m[32mnix = { version = "0.28.0", features = ["fs", "process", "signal", "term", "user", "time", "hostname"]}[m
 termion = "3.0.0"[m
 unicode-width = "0.1.11"[m
 signal-hook = "0.3.17"[m
 glob = "0.3.1"[m
 itertools = "0.12.1"[m
 rev_lines = "0.3.0"[m
[32m+[m[32mfaccess = "0.2.4"[m
[1mdiff --git a/LICENSE b/LICENSE[m
[1mindex 6e268bbe..fafd2dd3 100644[m
[1m--- a/LICENSE[m
[1m+++ b/LICENSE[m
[36m@@ -1,6 +1,6 @@[m
 BSD 3-Clause License[m
 [m
[31m-Copyright (c) 2022, Ryuichi Ueda[m
[32m+[m[32mCopyright (c) 2024, Ryuichi Ueda[m
 All rights reserved.[m
 [m
 Redistribution and use in source and binary forms, with or without[m
[1mdiff --git a/README.md b/README.md[m
[1mindex b1257c03..517aa235 100644[m
[1m--- a/README.md[m
[1m+++ b/README.md[m
[36m@@ -18,13 +18,13 @@[m [mA clone of Bash, which is developed as a hobby of our group and for monthly arti[m
 ## Quick Start[m
 [m
 ```bash[m
[31m-$ git clone https://github.com/shellgei/rusty_bash.git[m
[31m-$ cd rusty_bash[m
[31m-$ cargo build[m
[31m-...[m
[31m-üç£ echo hello[m
[31m-hello[m
[31m-üç£ exit[m
[32m+[m[32mueda@uedaP1g6:~$ git clone https://github.com/shellgei/rusty_bash.git[m
[32m+[m[32mueda@uedaP1g6:~$ cd rusty_bash[m
[32m+[m[32mueda@uedaP1g6:~$ cargo run[m
[32m+[m[32m   Compiling sush v2025.6.9 (/home/ueda/GIT/rusty_bash)[m
[32m+[m[32m    Finished dev [unoptimized + debuginfo] target(s) in 2.33s[m
[32m+[m[32m     Running `target/debug/sush`[m
[32m+[m[32mueda@uedaP1g6:~üç£ mainüåµ[m
 ```[m
 [m
 ## For Contributors [m
[36m@@ -32,8 +32,6 @@[m [mhello[m
 Since the main branch must synchronize the articles, further developments are reflected in the following branches. We prepared dev-* branches for adding your codes with pull requests.[m
 * [dev-builtins](https://github.com/shellgei/rusty_bash/tree/dev-builtins): for builtin commands [m
 * [dev-signal](https://github.com/shellgei/rusty_bash/tree/dev-signal): for development on signal[m
[31m-* [dev-compounds](https://github.com/shellgei/rusty_bash/tree/dev-compounds): for development on compoundss[m
[31m-* [dev-args](https://github.com/shellgei/rusty_bash/tree/dev-args): for development on arguments[m
 * [dev-test](https://github.com/shellgei/rusty_bash/tree/dev-test): for development of a nice test system and test cases (we need more sophisticated test)[m
 * [dev-others](https://github.com/shellgei/rusty_bash/tree/dev-others): for development of other features[m
 [m
[36m@@ -45,6 +43,12 @@[m [mThese dev-* branches will be merged to the main branch depending on the situatio[m
 * :construction: :partially available (or having known bugs) [m
 * :no_good: : not implemented[m
 [m
[32m+[m[32m### simple commands[m
[32m+[m
[32m+[m[32m|features | status |features | status |features | status |[m
[32m+[m[32m|-------------------|----|-------------------|----|-------------------|----|[m
[32m+[m[32m| command | :heavy_check_mark: | substitutions | :heavy_check_mark: | function definition | :heavy_check_mark: |[m[41m [m
[32m+[m
 [m
 ### compound commands[m
 [m
[36m@@ -54,7 +58,6 @@[m [mThese dev-* branches will be merged to the main branch depending on the situatio[m
 | {} | :heavy_check_mark: | case | :no_good: | until | :no_good: | select | :no_good: | [m
 | for | :no_good: |[m
 [m
[31m-[m
 ### control operator[m
 [m
 |features | status |features | status |features | status |[m
[36m@@ -63,6 +66,15 @@[m [mThese dev-* branches will be merged to the main branch depending on the situatio[m
 | ;; | :heavy_check_mark: | \| | :heavy_check_mark: | & | :heavy_check_mark: |[m
 | \|& | :heavy_check_mark: | [m
 [m
[32m+[m[32m### expansion[m
[32m+[m
[32m+[m[32m|features | status |features | status |features | status |[m
[32m+[m[32m|-------------------|----|-------------------|----|-------------------|----|[m
[32m+[m[32m| brace `{a,b}` | :heavy_check_mark: | brace `{1..10}` | :no_good: | tilde | :heavy_check_mark: |[m
[32m+[m[32m| parameter/variable `$A ${A}` | :heavy_check_mark: | parameter/variable  (others) | :no_good: | command substitution | :heavy_check_mark: |[m
[32m+[m[32m| arithmetic | :no_good: | word splitting | :heavy_check_mark: | path name | :heavy_check_mark: |[m
[32m+[m
[32m+[m
 ### builtin commands[m
 [m
 |features | status |features | status |features | status |[m
[36m@@ -88,6 +100,12 @@[m [mThese dev-* branches will be merged to the main branch depending on the situatio[m
 | umask | :no_good: | unalias | :no_good: | unset | :no_good: |[m
 | wait | :no_good: | export | :no_good: | false | :heavy_check_mark: |[m
 [m
[32m+[m[32m### beyond Bash[m
[32m+[m
[32m+[m[32m|features | status |[m
[32m+[m[32m|-------------------|----|[m
[32m+[m[32m| branch display in prompt | :heavy_check_mark: |[m
[32m+[m
 ## Thanks to[m
 [m
 Partially in Japanese.[m
[36m@@ -97,4 +115,3 @@[m [mPartially in Japanese.[m
     * [Rust„ÅßÂßã„ÇÅ„ÇãËá™‰Ωú„Ç∑„Çß„É´ „Åù„ÅÆ1 | „Å∂„Å¶„ÅÑ„ÅÆ„É≠„Ç∞„Åß„Å∂„É≠„Ç∞](https://tech.buty4649.net/entry/2021/12/19/235124)[m
     * [Rust„ÅÆ„Çø„Éº„Éü„Éä„É´Êìç‰Ωúcrate„ÅÑ„Çç„ÅÑ„Çç | meganehouser](https://meganehouser.github.io/2019-12-11_rust-terminal-crates.html)[m
     * [ÂéüÁêÜÂéüÂâá„ÅßÁêÜËß£„Åô„Çã„Éï„Ç©„Ç¢„Ç∞„É©„Ç¶„É≥„Éâ„Éó„É≠„Çª„Çπ„Å®„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Éó„É≠„Çª„Çπ„ÅÆÈÅï„ÅÑ | @tajima_taso](https://qiita.com/tajima_taso/items/c5553762af5e1a599fed)[m
[31m-[m
[1mdiff --git a/src/core.rs b/src/core.rs[m
[1mindex 185ecf04..8fdde193 100644[m
[1m--- a/src/core.rs[m
[1m+++ b/src/core.rs[m
[36m@@ -15,6 +15,7 @@[m [muse nix::sys::signal::{Signal, SigHandler};[m
 use nix::sys::wait::WaitStatus;[m
 use nix::unistd::Pid;[m
 use crate::core::jobtable::JobEntry;[m
[32m+[m[32muse crate::elements::command::Command;[m
 use std::sync::Arc;[m
 use std::sync::atomic::AtomicBool;[m
 use std::sync::atomic::Ordering::Relaxed;[m
[36m@@ -22,6 +23,8 @@[m [muse std::sync::atomic::Ordering::Relaxed;[m
 pub struct ShellCore {[m
     pub flags: String,[m
     parameters: HashMap<String, String>,[m
[32m+[m[32m    pub position_parameters: Vec<String>,[m
[32m+[m[32m    pub functions: HashMap<String, Box<dyn Command>>,[m
     rewritten_history: HashMap<usize, String>,[m
     pub history: Vec<String>,[m
     pub builtins: HashMap<String, fn(&mut ShellCore, &mut Vec<String>) -> i32>,[m
[36m@@ -47,6 +50,8 @@[m [mimpl ShellCore {[m
         let mut core = ShellCore{[m
             flags: String::new(),[m
             parameters: HashMap::new(),[m
[32m+[m[32m            position_parameters: vec![],[m
[32m+[m[32m            functions: HashMap::new(),[m
             rewritten_history: HashMap::new(),[m
             history: vec![],[m
             builtins: HashMap::new(),[m
[36m@@ -63,7 +68,7 @@[m [mimpl ShellCore {[m
 [m
         if unistd::isatty(0) == Ok(true) {[m
             core.flags += "i";[m
[31m-            core.set_param("PS1", "üç£ ");[m
[32m+[m[32m            core.set_param("PS1", r"\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\b\[\033[00m\]\[\033[01;35m\]\w\[\033[00m\]üç£ ");[m
             core.set_param("PS2", "> ");[m
             let fd = fcntl::fcntl(2, fcntl::F_DUPFD_CLOEXEC(255))[m
                 .expect("sush(fatal): Can't allocate fd for tty FD");[m
[36m@@ -145,14 +150,14 @@[m [mimpl ShellCore {[m
             panic!("SUSH INTERNAL ERROR (no arg for builtins)");[m
         }[m
 [m
[31m-        if ! self.builtins.contains_key(&args[0]) {[m
[31m-            return false;[m
[32m+[m[32m        if self.builtins.contains_key(&args[0]) {[m
[32m+[m[32m            let func = self.builtins[&args[0]];[m
[32m+[m[32m            let status = func(self, args);[m
[32m+[m[32m            self.parameters.insert("?".to_string(), status.to_string());[m
[32m+[m[32m            return true;[m
         }[m
 [m
[31m-        let func = self.builtins[&args[0]];[m
[31m-        let status = func(self, args);[m
[31m-        self.parameters.insert("?".to_string(), status.to_string());[m
[31m-        true[m
[32m+[m[32m        false[m
     }[m
 [m
     pub fn exit(&self) -> ! {[m
[1mdiff --git a/src/core/builtins.rs b/src/core/builtins.rs[m
[1mindex 05b9f31b..e2615788 100644[m
[1m--- a/src/core/builtins.rs[m
[1m+++ b/src/core/builtins.rs[m
[36m@@ -15,6 +15,7 @@[m [mimpl ShellCore {[m
         self.builtins.insert("exit".to_string(), exit);[m
         self.builtins.insert("false".to_string(), false_);[m
         self.builtins.insert("pwd".to_string(), pwd::pwd);[m
[32m+[m[32m        self.builtins.insert("set".to_string(), set);[m
         self.builtins.insert("true".to_string(), true_);[m
     }[m
 }[m
[36m@@ -31,6 +32,11 @@[m [mpub fn false_(_: &mut ShellCore, _: &mut Vec<String>) -> i32 {[m
     1[m
 }[m
 [m
[32m+[m[32mpub fn set(core: &mut ShellCore, args: &mut Vec<String>) -> i32 {[m
[32m+[m[32m    core.position_parameters = args.to_vec();[m
[32m+[m[32m    0[m
[32m+[m[32m}[m
[32m+[m
 pub fn true_(_: &mut ShellCore, _: &mut Vec<String>) -> i32 {[m
     0[m
 }[m
[1mdiff --git a/src/core/parameter.rs b/src/core/parameter.rs[m
[1mindex 5e53b75a..3872f806 100644[m
[1m--- a/src/core/parameter.rs[m
[1m+++ b/src/core/parameter.rs[m
[36m@@ -6,6 +6,10 @@[m [muse std::env;[m
 [m
 impl ShellCore {[m
     pub fn get_param_ref(&mut self, key: &str) -> &str {[m
[32m+[m[32m        if let Some(n) = self.get_position_param_pos(key) {[m
[32m+[m[32m            return &self.position_parameters[n];[m
[32m+[m[32m        }[m
[32m+[m
         if  self.parameters.get(key) == None {[m
             if let Ok(val) = env::var(key) {[m
                 self.set_param(key, &val);[m
[36m@@ -18,7 +22,25 @@[m [mimpl ShellCore {[m
         }[m
     }[m
 [m
[32m+[m[32m    fn get_position_param_pos(&self, key: &str) -> Option<usize> {[m
[32m+[m[32m        if ! (key.len() == 1 && "0" <= key && key <= "9") {[m
[32m+[m[32m            return None;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        let n = key.parse::<usize>().unwrap();[m
[32m+[m[32m        if n < self.position_parameters.len() {[m
[32m+[m[32m            Some(n)[m
[32m+[m[32m        }else{[m
[32m+[m[32m            None[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
     pub fn set_param(&mut self, key: &str, val: &str) {[m
[32m+[m[32m        match env::var(key) {[m
[32m+[m[32m            Ok(_) => env::set_var(key, val),[m
[32m+[m[32m            _     => {},[m
[32m+[m[32m        }[m
[32m+[m
         self.parameters.insert(key.to_string(), val.to_string());[m
     }[m
 }[m
[1mdiff --git a/src/elements/command.rs b/src/elements/command.rs[m
[1mindex ead0e289..a177eda3 100644[m
[1m--- a/src/elements/command.rs[m
[1m+++ b/src/elements/command.rs[m
[36m@@ -4,6 +4,7 @@[m
 pub mod simple;[m
 pub mod paren;[m
 pub mod brace;[m
[32m+[m[32mpub mod function_def;[m
 pub mod r#while;[m
 pub mod r#if;[m
 [m
[36m@@ -11,6 +12,7 @@[m [muse crate::{ShellCore, Feeder, Script};[m
 use self::simple::SimpleCommand;[m
 use self::paren::ParenCommand;[m
 use self::brace::BraceCommand;[m
[32m+[m[32muse self::function_def::FunctionDefinition;[m
 use self::r#while::WhileCommand;[m
 use self::r#if::IfCommand;[m
 use std::fmt;[m
[36m@@ -114,10 +116,11 @@[m [mpub fn eat_redirects(feeder: &mut Feeder, core: &mut ShellCore,[m
 }[m
 [m
 pub fn parse(feeder: &mut Feeder, core: &mut ShellCore) -> Option<Box<dyn Command>> {[m
[31m-    if let Some(a) = SimpleCommand::parse(feeder, core){ Some(Box::new(a)) }[m
[32m+[m[32m    if let Some(a) = FunctionDefinition::parse(feeder, core) { Some(Box::new(a)) }[m
[32m+[m[32m    else if let Some(a) = SimpleCommand::parse(feeder, core){ Some(Box::new(a)) }[m
[32m+[m[32m    else if let Some(a) = IfCommand::parse(feeder, core) { Some(Box::new(a)) }[m
     else if let Some(a) = ParenCommand::parse(feeder, core, false) { Some(Box::new(a)) }[m
     else if let Some(a) = BraceCommand::parse(feeder, core) { Some(Box::new(a)) }[m
     else if let Some(a) = WhileCommand::parse(feeder, core) { Some(Box::new(a)) }[m
[31m-    else if let Some(a) = IfCommand::parse(feeder, core) { Some(Box::new(a)) }[m
     else{ None }[m
 }[m
[1mdiff --git a/src/elements/command/function_def.rs b/src/elements/command/function_def.rs[m
[1mnew file mode 100644[m
[1mindex 00000000..ecb9c484[m
[1m--- /dev/null[m
[1m+++ b/src/elements/command/function_def.rs[m
[36m@@ -0,0 +1,110 @@[m
[32m+[m[32m//SPDX-FileCopyrightText: 2022 Ryuichi Ueda ryuichiueda@gmail.com[m
[32m+[m[32m//SPDX-License-Identifier: BSD-3-Clause[m
[32m+[m
[32m+[m[32muse crate::{ShellCore, Feeder};[m
[32m+[m[32muse super::{Command, Pipe, Redirect};[m
[32m+[m[32muse crate::elements::command;[m
[32m+[m[32muse crate::elements::command::{BraceCommand, IfCommand, ParenCommand, WhileCommand};[m
[32m+[m[32muse nix::unistd::Pid;[m
[32m+[m
[32m+[m[32mfn reserved(w: &str) -> bool {[m
[32m+[m[32m    match w {[m
[32m+[m[32m        "{" | "}" | "while" | "do" | "done" | "if" | "then" | "elif" | "else" | "fi" => true,[m
[32m+[m[32m        _ => false,[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[derive(Debug, Clone)][m
[32m+[m[32mpub struct FunctionDefinition {[m
[32m+[m[32m    text: String,[m
[32m+[m[32m    name: String,[m
[32m+[m[32m    command: Option<Box<dyn Command>>,[m
[32m+[m[32m    redirects: Vec<Redirect>,[m
[32m+[m[32m    force_fork: bool,[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mimpl Command for FunctionDefinition {[m
[32m+[m[32m    fn exec(&mut self, core: &mut ShellCore, pipe: &mut Pipe) -> Option<Pid> {[m
[32m+[m[32m        if self.force_fork || pipe.is_connected() {[m
[32m+[m[32m            return None;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        core.functions.insert(self.name.to_string(), self.command.as_mut().unwrap().clone());[m
[32m+[m[32m        None[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn run(&mut self, _: &mut ShellCore, _: bool) { }[m
[32m+[m[32m    fn get_text(&self) -> String { self.text.clone() }[m
[32m+[m[32m    fn get_redirects(&mut self) -> &mut Vec<Redirect> { &mut self.redirects }[m
[32m+[m[32m    fn set_force_fork(&mut self) { self.force_fork = true; }[m
[32m+[m[32m    fn boxed_clone(&self) -> Box<dyn Command> {Box::new(self.clone())}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mimpl FunctionDefinition {[m
[32m+[m[32m    fn new() -> FunctionDefinition {[m
[32m+[m[32m        FunctionDefinition {[m
[32m+[m[32m            text: String::new(),[m
[32m+[m[32m            name: String::new(),[m
[32m+[m[32m            command: None,[m
[32m+[m[32m            redirects: vec![],[m
[32m+[m[32m            force_fork: false,[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn eat_name(feeder: &mut Feeder, ans: &mut Self, core: &mut ShellCore) -> bool {[m
[32m+[m[32m        let len = feeder.scanner_name(core);[m
[32m+[m[32m        ans.name = feeder.consume(len).to_string();[m
[32m+[m
[32m+[m[32m        if ans.name.len() == 0 && reserved(&ans.name) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        ans.text += &ans.name;[m
[32m+[m[32m        command::eat_blank_with_comment(feeder, core, &mut ans.text);[m
[32m+[m
[32m+[m[32m        true[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn eat_compound_command(feeder: &mut Feeder, ans: &mut Self, core: &mut ShellCore) -> bool {[m
[32m+[m[32m        ans.command = if let Some(a) = IfCommand::parse(feeder, core) { Some(Box::new(a)) }[m
[32m+[m[32m        else if let Some(a) = ParenCommand::parse(feeder, core, false) { Some(Box::new(a)) }[m
[32m+[m[32m        else if let Some(a) = BraceCommand::parse(feeder, core) { Some(Box::new(a)) }[m
[32m+[m[32m        else if let Some(a) = WhileCommand::parse(feeder, core) { Some(Box::new(a)) }[m
[32m+[m[32m        else {None};[m
[32m+[m
[32m+[m[32m        if let Some(c) = &ans.command {[m
[32m+[m[32m            ans.text += &c.get_text();[m
[32m+[m[32m            true[m
[32m+[m[32m        }else{[m
[32m+[m[32m            false[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn parse(feeder: &mut Feeder, core: &mut ShellCore) -> Option<Self> {[m
[32m+[m[32m        let mut ans = Self::new();[m
[32m+[m[32m        feeder.set_backup();[m
[32m+[m
[32m+[m[32m        if feeder.starts_with("function") {[m
[32m+[m[32m            ans.text += &feeder.consume(8);[m
[32m+[m[32m            command::eat_blank_with_comment(feeder, core, &mut ans.text);[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        if ! Self::eat_name(feeder, &mut ans, core)[m[41m [m
[32m+[m[32m        || ! feeder.starts_with("()") {[m
[32m+[m[32m            feeder.rewind();[m
[32m+[m[32m            return None;[m
[32m+[m[32m        }[m
[32m+[m[32m        ans.text += &feeder.consume(2);[m
[32m+[m[32m        command::eat_blank_with_comment(feeder, core, &mut ans.text);[m
[32m+[m
[32m+[m[32m        Self::eat_compound_command(feeder, &mut ans, core);[m
[32m+[m[32m        command::eat_blank_with_comment(feeder, core, &mut ans.text);[m
[32m+[m
[32m+[m[32m        if let Some(_) = &ans.command {[m
[32m+[m[32m            feeder.pop_backup();[m
[32m+[m[32m            Some(ans)[m
[32m+[m[32m        }else{[m
[32m+[m[32m            feeder.rewind();[m
[32m+[m[32m            None[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/src/elements/command/simple.rs b/src/elements/command/simple.rs[m
[1mindex 83f200d5..244dd00d 100644[m
[1m--- a/src/elements/command/simple.rs[m
[1m+++ b/src/elements/command/simple.rs[m
[36m@@ -50,6 +50,8 @@[m [mimpl Command for SimpleCommand {[m
             return None;[m
         }else if Self::check_sigint(core) {[m
             None[m
[32m+[m[32m        }else if core.functions.contains_key(&self.args[0]) {[m
[32m+[m[32m            self.exec_function(core, pipe)[m
         }else{[m
             self.exec_command(core, pipe)[m
         }[m
[36m@@ -109,6 +111,20 @@[m [mimpl SimpleCommand {[m
         }[m
     }[m
 [m
[32m+[m[32m    fn exec_function(&mut self, core: &mut ShellCore, pipe: &mut Pipe) -> Option<Pid> {[m
[32m+[m[32m        let mut command = core.functions[&self.args[0]].clone();[m
[32m+[m
[32m+[m[32m        let backup = core.position_parameters.to_vec();[m
[32m+[m[32m        self.args[0] = backup[0].clone();[m
[32m+[m[32m        core.position_parameters = self.args.to_vec();[m
[32m+[m
[32m+[m[32m        let pid = command.exec(core, pipe);[m
[32m+[m
[32m+[m[32m        core.position_parameters = backup;[m
[32m+[m
[32m+[m[32m        return pid;[m
[32m+[m[32m    }[m
[32m+[m
     fn check_sigint(core: &mut ShellCore) -> bool {[m
         if core.sigint.load(Relaxed) {[m
             core.set_param("?", "130");[m
[1mdiff --git a/src/elements/subword/double_quoted.rs b/src/elements/subword/double_quoted.rs[m
[1mindex 2162a9c8..8971de91 100644[m
[1m--- a/src/elements/subword/double_quoted.rs[m
[1m+++ b/src/elements/subword/double_quoted.rs[m
[36m@@ -28,6 +28,7 @@[m [mimpl Subword for DoubleQuoted {[m
         true[m
     }[m
 [m
[32m+[m
     fn unquote(&mut self) {[m
         self.subwords.iter_mut().for_each(|sw| sw.unquote());[m
         self.text = self.subwords.iter().map(|s| s.get_text()).collect();[m
[1mdiff --git a/src/feeder.rs b/src/feeder.rs[m
[1mindex a167327d..56bf0885 100644[m
[1m--- a/src/feeder.rs[m
[1m+++ b/src/feeder.rs[m
[36m@@ -108,9 +108,6 @@[m [mimpl Feeder {[m
     }[m
 [m
     pub fn feed_line(&mut self, core: &mut ShellCore) -> Result<(), InputError> {[m
[31m-        let pwd = core.get_param_ref("PWD").to_string();[m
[31m-        core.set_param("PS1", &(pwd + "üç£ "));[m
[31m-[m
         let line = match core.has_flag('i') {[m
             true  => terminal::read_line(core, "PS1"),[m
             false => Self::read_line_stdin(),[m
[1mdiff --git a/src/feeder/terminal.rs b/src/feeder/terminal.rs[m
[1mindex 926582fb..2d01f3d1 100644[m
[1m--- a/src/feeder/terminal.rs[m
[1m+++ b/src/feeder/terminal.rs[m
[36m@@ -1,10 +1,16 @@[m
 //SPDX-FileCopyrightText: 2024 Ryuichi Ueda ryuichiueda@gmail.com[m
 //SPDX-License-Identifier: BSD-3-Clause[m
 [m
[32m+[m[32mmod completion;[m
[32m+[m
 use crate::{InputError, ShellCore};[m
 use std::io;[m
[32m+[m[32muse std::fs::File;[m
 use std::io::{Write, Stdout};[m
 use std::sync::atomic::Ordering::Relaxed;[m
[32m+[m[32muse std::path::Path;[m
[32m+[m[32muse nix::unistd;[m
[32m+[m[32muse nix::unistd::User;[m
 use termion::cursor::DetectCursorPos;[m
 use termion::event;[m
 use termion::raw::{IntoRawMode, RawTerminal};[m
[36m@@ -18,12 +24,19 @@[m [mstruct Terminal {[m
     chars: Vec<char>,[m
     head: usize,[m
     hist_ptr: usize,[m
[32m+[m[32m    prompt_width_map: Vec<usize>,[m
[32m+[m[32m    /* for completion */[m
[32m+[m[32m    tilde_prefix: String,[m
[32m+[m[32m    tilde_path: String,[m
 }[m
 [m
 impl Terminal {[m
     pub fn new(core: &mut ShellCore, ps: &str) -> Self {[m
[31m-        let prompt = core.get_param_ref(ps);[m
[31m-        print!("\x1b[1;35m{}\x1b[m", prompt);[m
[32m+[m[32m        let raw_prompt = core.get_param_ref(ps);[m
[32m+[m[32m        let ansi_on_prompt = raw_prompt.replace("\\033", "\x1b").to_string();[m
[32m+[m[32m        let replaced_prompt = Self::make_prompt_string(&ansi_on_prompt);[m
[32m+[m[32m        let prompt = replaced_prompt.replace("\\[", "").replace("\\]", "").to_string();[m
[32m+[m[32m        print!("{}", prompt);[m
         io::stdout().flush().unwrap();[m
 [m
         let mut sout = io::stdout().into_raw_mode().unwrap();[m
[36m@@ -36,7 +49,82 @@[m [mimpl Terminal {[m
             chars: prompt.chars().collect(),[m
             head: prompt.chars().count(),[m
             hist_ptr: 0,[m
[32m+[m[32m            prompt_width_map: Self::make_width_map(&replaced_prompt),[m
[32m+[m[32m            tilde_path: String::new(),[m
[32m+[m[32m            tilde_prefix: String::new(),[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn get_branch(cwd: &String) -> String {[m
[32m+[m[32m        let mut dirs: Vec<String> = cwd.split("/").map(|s| s.to_string()).collect();[m
[32m+[m[32m        while dirs.len() > 0 {[m
[32m+[m[32m            let path = dirs.join("/") + "/.git/HEAD";[m
[32m+[m[32m            dirs.pop();[m
[32m+[m
[32m+[m[32m            let p = Path::new(&path);[m
[32m+[m[32m            if p.is_file() {[m
[32m+[m[32m                if let Ok(mut f) = File::open(p){[m
[32m+[m[32m                    return match f.read_line() {[m
[32m+[m[32m                        Ok(Some(s)) => s.replace("ref: refs/heads/","") + "üåµ",[m
[32m+[m[32m                        _ => "".to_string(),[m
[32m+[m[32m                    };[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        "".to_string()[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn make_prompt_string(raw: &str) -> String {[m
[32m+[m[32m        let uid = unistd::getuid();[m
[32m+[m[32m        let user = match User::from_uid(uid) {[m
[32m+[m[32m            Ok(Some(u)) => u.name,[m
[32m+[m[32m            _ => "".to_string(),[m
[32m+[m[32m        };[m
[32m+[m[32m        let hostname = match unistd::gethostname() {[m
[32m+[m[32m            Ok(h) => h.to_string_lossy().to_string(),[m
[32m+[m[32m            _ => "".to_string(),[m
[32m+[m[32m        };[m
[32m+[m
[32m+[m[32m        let homedir = match User::from_uid(uid) {[m
[32m+[m[32m            Ok(Some(u)) => u.dir.to_string_lossy().to_string(),[m
[32m+[m[32m            _ => "".to_string(),[m
[32m+[m[32m        };[m
[32m+[m[32m        let mut cwd = match unistd::getcwd() {[m
[32m+[m[32m            Ok(p) => p.to_string_lossy()[m
[32m+[m[32m                      .to_string(),[m
[32m+[m[32m            _ => "".to_string(),[m
[32m+[m[32m        };[m
[32m+[m[32m        let branch = Self::get_branch(&cwd);[m
[32m+[m
[32m+[m[32m        if cwd.starts_with(&homedir) {[m
[32m+[m[32m            cwd = cwd.replacen(&homedir, "~", 1);[m
         }[m
[32m+[m
[32m+[m[32m        raw.replace("\\u", &user)[m
[32m+[m[32m           .replace("\\h", &hostname)[m
[32m+[m[32m           .replace("\\w", &cwd)[m
[32m+[m[32m           .replace("\\b", &branch)[m
[32m+[m[32m           .to_string()[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn make_width_map(prompt: &str) -> Vec<usize> {[m
[32m+[m[32m        let tmp = prompt.replace("\\[", "\x01").replace("\\]", "\x02").to_string();[m
[32m+[m[32m        let mut in_escape = false;[m
[32m+[m[32m        let mut ans = vec![];[m
[32m+[m[32m        for c in tmp.chars() {[m
[32m+[m[32m            if c == '\x01' || c == '\x02' {[m
[32m+[m[32m                in_escape = c == '\x01';[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            let wid = match in_escape {[m
[32m+[m[32m                true  => 0,[m
[32m+[m[32m                false => UnicodeWidthStr::width(c.to_string().as_str()),[m
[32m+[m[32m            };[m
[32m+[m[32m            ans.push(wid);[m
[32m+[m[32m        }[m
[32m+[m[32m        ans[m
     }[m
 [m
     fn write(&mut self, s: &str) {[m
[36m@@ -47,8 +135,12 @@[m [mimpl Terminal {[m
         self.stdout.flush().unwrap();[m
     }[m
 [m
[31m-    fn char_width(c: &char) -> usize {[m
[31m-         UnicodeWidthStr::width(c.to_string().as_str())[m
[32m+[m[32m    fn char_width(&self, c: &char, pos: usize) -> usize {[m
[32m+[m[32m        if pos < self.prompt.chars().count() {[m
[32m+[m[32m            return self.prompt_width_map[pos];[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        UnicodeWidthStr::width(c.to_string().as_str())[m
     }[m
 [m
     fn size() -> (usize, usize) {[m
[36m@@ -66,8 +158,8 @@[m [mimpl Terminal {[m
         let col = Terminal::size().0;[m
         let (mut x, mut y) = (0, y_origin);[m
 [m
[31m-        for c in &self.chars[..head] {[m
[31m-            let w = Self::char_width(c);[m
[32m+[m[32m        for (i, c) in self.chars[..head].iter().enumerate() {[m
[32m+[m[32m            let w = self.char_width(c, i);[m
             if x + w > col {[m
                 y += 1;[m
                 x = w;[m
[36m@@ -93,8 +185,7 @@[m [mimpl Terminal {[m
         if erase {[m
             self.write(&termion::clear::AfterCursor.to_string());[m
         }[m
[31m-        print!("\x1b[1;35m{}\x1b[m", self.prompt);[m
[31m-        self.write(&self.get_string(self.prompt.chars().count()));[m
[32m+[m[32m        self.write(&self.get_string(0));[m
         self.goto(self.head);[m
         self.flush();[m
     }[m
[36m@@ -139,9 +230,16 @@[m [mimpl Terminal {[m
     }[m
 [m
     pub fn shift_cursor(&mut self, shift: i32) {[m
[32m+[m[32m        let prev = self.head;[m
         Self::shift_in_range(&mut self.head, shift, [m
                              self.prompt.chars().count(),[m
                              self.chars.len());[m
[32m+[m
[32m+[m[32m        if prev == self.head {[m
[32m+[m[32m            self.cloop();[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
         self.goto(self.head);[m
         self.flush();[m
     }[m
[36m@@ -178,15 +276,22 @@[m [mimpl Terminal {[m
         self.head = self.chars.len();[m
         self.rewrite(true);[m
     }[m
[32m+[m
[32m+[m[32m    pub fn cloop(&mut self) {[m
[32m+[m[32m        print!("\x07");[m
[32m+[m[32m        self.flush();[m
[32m+[m[32m    }[m
 }[m
 [m
 pub fn read_line(core: &mut ShellCore, prompt: &str) -> Result<String, InputError>{[m
     let mut term = Terminal::new(core, prompt);[m
     let mut term_size = Terminal::size();[m
     core.history.insert(0, String::new());[m
[32m+[m[32m    let mut prev_key = event::Key::Char('a');[m
 [m
     for c in io::stdin().keys() {[m
         term.check_size_change(&mut term_size);[m
[32m+[m
         match c.as_ref().unwrap() {[m
             event::Key::Ctrl('a') => term.goto_origin(),[m
             event::Key::Ctrl('b') => term.shift_cursor(-1),[m
[36m@@ -218,12 +323,16 @@[m [mpub fn read_line(core: &mut ShellCore, prompt: &str) -> Result<String, InputErro[m
                 term.chars.push('\n');[m
                 break;[m
             },[m
[32m+[m[32m            event::Key::Char('\t') => {[m
[32m+[m[32m                term.completion(core, prev_key == event::Key::Char('\t'));[m
[32m+[m[32m            },[m
             event::Key::Char(c) => {[m
                 term.insert(*c);[m
             },[m
             _  => {},[m
         }[m
         term.check_scroll();[m
[32m+[m[32m        prev_key = c.as_ref().unwrap().clone();[m
     }[m
 [m
     core.history[0] = term.get_string(term.prompt.chars().count());[m
[1mdiff --git a/src/feeder/terminal/completion.rs b/src/feeder/terminal/completion.rs[m
[1mnew file mode 100644[m
[1mindex 00000000..c750eb80[m
[1m--- /dev/null[m
[1m+++ b/src/feeder/terminal/completion.rs[m
[36m@@ -0,0 +1,226 @@[m
[32m+[m[32m//SPDX-FileCopyrightText: 2024 Ryuichi Ueda ryuichiueda@gmail.com[m
[32m+[m[32m//SPDX-License-Identifier: BSD-3-Clause[m
[32m+[m
[32m+[m[32muse crate::ShellCore;[m
[32m+[m[32muse crate::feeder::terminal::Terminal;[m
[32m+[m[32muse faccess;[m
[32m+[m[32muse faccess::PathExt;[m
[32m+[m[32muse glob;[m
[32m+[m[32muse glob::{GlobError, MatchOptions};[m
[32m+[m[32muse std::collections::HashSet;[m
[32m+[m[32muse std::path::PathBuf;[m
[32m+[m[32muse unicode_width::UnicodeWidthStr;[m
[32m+[m
[32m+[m[32mfn expand(path: &str, executable_only: bool, search_dir: bool) -> Vec<String> {[m
[32m+[m[32m    let opts = MatchOptions {[m
[32m+[m[32m        case_sensitive: true,[m
[32m+[m[32m        require_literal_separator: true,[m
[32m+[m[32m        require_literal_leading_dot: false,[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    let mut ans: Vec<String> = match glob::glob_with(&path, opts) {[m
[32m+[m[32m        Ok(ps) => ps.map(|p| to_str(&p, executable_only, search_dir))[m
[32m+[m[32m                    .filter(|s| s != "").collect(),[m
[32m+[m[32m        _ => return vec![],[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    ans.sort();[m
[32m+[m[32m    ans[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfn to_str(path :&Result<PathBuf, GlobError>, executable_only: bool, search_dir: bool) -> String {[m
[32m+[m[32m    match path {[m
[32m+[m[32m        Ok(p) => {[m
[32m+[m[32m            if ( executable_only && ! p.executable() && ! p.is_dir() )[m
[32m+[m[32m            || ( ! search_dir && p.is_dir() ) {[m
[32m+[m[32m                return "".to_string();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            let mut s = p.to_string_lossy().to_string();[m
[32m+[m[32m            if p.is_dir() && s.chars().last() != Some('/') {[m
[32m+[m[32m                s.push('/');[m
[32m+[m[32m            }[m
[32m+[m[32m            s[m
[32m+[m[32m        },[m
[32m+[m[32m        _ => "".to_string(),[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfn common_length(chars: &Vec<char>, s: &String) -> usize {[m
[32m+[m[32m    let max_len = chars.len();[m
[32m+[m[32m    for (i, c) in s.chars().enumerate() {[m
[32m+[m[32m        if i >= max_len || chars[i] != c {[m
[32m+[m[32m            return i;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    max_len[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfn common_string(paths: &Vec<String>) -> String {[m
[32m+[m[32m    if paths.len() == 0 {[m
[32m+[m[32m        return "".to_string();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    let ref_chars: Vec<char> = paths[0].chars().collect();[m
[32m+[m[32m    let mut common_len = ref_chars.len();[m
[32m+[m
[32m+[m[32m    for path in &paths[1..] {[m
[32m+[m[32m        let len = common_length(&ref_chars, &path);[m
[32m+[m[32m        common_len = std::cmp::min(common_len, len);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ref_chars[..common_len].iter().collect()[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mimpl Terminal {[m
[32m+[m[32m    pub fn completion(&mut self, core: &mut ShellCore, double_tab: bool) {[m
[32m+[m[32m        let input = self.get_string(self.prompt.chars().count());[m
[32m+[m[32m        let words: Vec<String> = input.split(" ").map(|e| e.to_string()).collect();[m
[32m+[m[32m        if words.len() == 0 || words.last().unwrap() == "" {[m
[32m+[m[32m            self.cloop();[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        let last = words.last().unwrap().clone();[m
[32m+[m
[32m+[m[32m        let mut command_pos = 0;[m
[32m+[m[32m        for w in &words {[m
[32m+[m[32m            match w.find("=") {[m
[32m+[m[32m                None => break,[m
[32m+[m[32m                _    => command_pos +=1,[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        let search_command = command_pos == words.len()-1;[m
[32m+[m
[32m+[m[32m        match search_command && ! last.starts_with(".") && ! last.starts_with("/"){[m
[32m+[m[32m            true  => self.command_completion(&last, core),[m
[32m+[m[32m            false => self.file_completion(&last, core, double_tab, search_command),[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn command_list(target: &String, core: &mut ShellCore) -> Vec<String> {[m
[32m+[m[32m        let mut comlist = HashSet::new();[m
[32m+[m[32m        for path in core.get_param_ref("PATH").to_string().split(":") {[m
[32m+[m[32m            for file in expand(&(path.to_string() + "/*"), true, false) {[m
[32m+[m[32m                let command = file.split("/").last().map(|s| s.to_string()).unwrap();[m
[32m+[m[32m                if command.starts_with(target) {[m
[32m+[m[32m                    comlist.insert(command.clone());[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        let mut ans: Vec<String> = comlist.iter().map(|c| c.to_string()).collect();[m
[32m+[m[32m        ans.sort();[m
[32m+[m[32m        ans[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn command_completion(&mut self, target: &String, core: &mut ShellCore) {[m
[32m+[m[32m        let comlist = Self::command_list(target, core);[m
[32m+[m[32m        match comlist.len() {[m
[32m+[m[32m            0 => self.cloop(),[m
[32m+[m[32m            1 => self.replace_input(&(comlist[0].to_string() + " "), &target),[m
[32m+[m[32m            _ => self.show_list(&comlist),[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn file_completion(&mut self, target: &String, core: &mut ShellCore,[m
[32m+[m[32m                           double_tab: bool, search_executable: bool) {[m
[32m+[m[32m        let mut wildcard = target.to_string() + "*";[m
[32m+[m
[32m+[m[32m        let mut target_tilde = target.to_string();[m
[32m+[m[32m        if target.starts_with("~/") {[m
[32m+[m[32m            self.tilde_prefix = "~/".to_string();[m
[32m+[m[32m            self.tilde_path = core.get_param_ref("HOME").to_string() + "/";[m
[32m+[m[32m            wildcard = wildcard.replacen(&self.tilde_prefix, &self.tilde_path, 1);[m[41m    [m
[32m+[m[32m            target_tilde = target_tilde.replacen(&self.tilde_prefix, &self.tilde_path, 1);[m
[32m+[m[32m        }else{[m
[32m+[m[32m            self.tilde_prefix = String::new();[m
[32m+[m[32m            self.tilde_path = String::new();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        let paths = expand(&wildcard, search_executable, true);[m
[32m+[m[32m        match paths.len() {[m
[32m+[m[32m            0 => self.cloop(),[m
[32m+[m[32m            1 => self.replace_input(&paths[0], &target),[m
[32m+[m[32m            _ => self.file_completion_multicands(&target_tilde, &paths, double_tab),[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn show_list(&mut self, list: &Vec<String>) {[m
[32m+[m[32m        eprintln!("\r");[m
[32m+[m
[32m+[m[32m        let widths: Vec<usize> = list.iter()[m
[32m+[m[32m                                     .map(|p| UnicodeWidthStr::width(p.as_str()))[m
[32m+[m[32m                                     .collect();[m
[32m+[m[32m        let max_entry_width = widths.iter().max().unwrap_or(&1000) + 1;[m
[32m+[m
[32m+[m[32m        let col_num = Terminal::size().0 / max_entry_width;[m
[32m+[m[32m        if col_num == 0 {[m
[32m+[m[32m            list.iter().for_each(|p| print!("{}\r\n", &p));[m
[32m+[m[32m            self.rewrite(true);[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        let row_num = (list.len()-1) / col_num + 1;[m
[32m+[m
[32m+[m[32m        for row in 0..row_num {[m
[32m+[m[32m            for col in 0..col_num {[m
[32m+[m[32m                let i = col*row_num + row;[m
[32m+[m[32m                if i >= list.len() {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                let space_num = max_entry_width - widths[i];[m
[32m+[m[32m                let s = String::from_utf8(vec![b' '; space_num]).unwrap();[m
[32m+[m[32m                print!("{}{}", list[i], &s);[m
[32m+[m[32m            }[m
[32m+[m[32m            print!("\r\n");[m
[32m+[m[32m        }[m
[32m+[m[32m        self.rewrite(true);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn file_completion_multicands(&mut self, dir: &String,[m
[32m+[m[32m                                      paths: &Vec<String>, double_tab: bool) {[m
[32m+[m[32m        let common = common_string(&paths);[m
[32m+[m[32m        if common.len() == dir.len() {[m
[32m+[m[32m            match double_tab {[m
[32m+[m[32m                true => self.show_path_candidates(&dir.to_string(), &paths),[m
[32m+[m[32m                false => self.cloop(),[m
[32m+[m[32m            }[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        self.replace_input(&common, &dir);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn show_path_candidates(&mut self, dir: &String, paths: &Vec<String>) {[m
[32m+[m[32m        let ps = if dir.chars().last() == Some('/') {[m
[32m+[m[32m            paths.iter()[m
[32m+[m[32m                 .map(|p| p.replacen(dir, "", 1)[m
[32m+[m[32m                 .replacen(&self.tilde_path, &self.tilde_prefix, 1))[m
[32m+[m[32m                 .collect()[m
[32m+[m[32m        }else{[m
[32m+[m[32m            paths.iter()[m
[32m+[m[32m                 .map(|p| p.replacen(&self.tilde_path, &self.tilde_prefix, 1))[m
[32m+[m[32m                 .collect()[m
[32m+[m[32m        };[m
[32m+[m
[32m+[m[32m        self.show_list(&ps);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    fn replace_input(&mut self, path: &String, last: &str) {[m
[32m+[m[32m        let last_char_num = last.chars().count();[m
[32m+[m[32m        let len = self.chars.len();[m
[32m+[m[32m        let mut path_chars = path.to_string();[m
[32m+[m
[32m+[m[32m        if last.starts_with("./") {[m
[32m+[m[32m            path_chars.insert(0, '/');[m
[32m+[m[32m            path_chars.insert(0, '.');[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        path_chars = path_chars.replacen(&self.tilde_path, &self.tilde_prefix, 1);[m
[32m+[m
[32m+[m[32m        self.chars.drain(len - last_char_num..);[m
[32m+[m[32m        self.chars.extend(path_chars.chars());[m
[32m+[m[32m        self.head = self.chars.len();[m
[32m+[m[32m        self.rewrite(false);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/src/main.rs b/src/main.rs[m
[1mindex 835042b1..2afcfe87 100644[m
[1m--- a/src/main.rs[m
[1m+++ b/src/main.rs[m
[36m@@ -1,4 +1,4 @@[m
[31m-//SPDX-FileCopyrightText: 2022 Ryuichi Ueda ryuichiueda@gmail.com[m
[32m+[m[32m//SPDX-FileCopyrightText: 2024 Ryuichi Ueda ryuichiueda@gmail.com[m
 //SPDX-License-Identifier: BSD-3-Clause[m
 [m
 mod core;[m
[36m@@ -8,7 +8,7 @@[m [mmod elements;[m
 use std::{env, process, thread, time};[m
 use std::sync::Arc;[m
 use std::sync::atomic::Ordering::Relaxed;[m
[31m-use crate::core::ShellCore;[m
[32m+[m[32muse crate::core::{builtins, ShellCore};[m
 use crate::elements::script::Script;[m
 use crate::feeder::{Feeder, InputError};[m
 use signal_hook::consts;[m
[36m@@ -52,12 +52,13 @@[m [mfn run_signal_check(core: &mut ShellCore) {[m
 } //thanks: https://dev.to/talzvon/handling-unix-kill-signals-in-rust-55g6[m
 [m
 fn main() {[m
[31m-    let args: Vec<String> = env::args().collect();[m
[32m+[m[32m    let mut args: Vec<String> = env::args().collect();[m
     if args.len() > 1 && args[1] == "--version" {[m
         show_version();[m
     }[m
 [m
     let mut core = ShellCore::new();[m
[32m+[m[32m    builtins::set(&mut core, &mut args);[m
     run_signal_check(&mut core);[m
     main_loop(&mut core);[m
 }[m
[1mdiff --git a/test/test.bash b/test/test.bash[m
[1mindex 02ff89bc..51090538 100755[m
[1m--- a/test/test.bash[m
[1m+++ b/test/test.bash[m
[36m@@ -173,6 +173,37 @@[m [mres=$($com <<< '{ echo a; }#aaaaa')[m
 res=$($com <<< '{ echo a; } #aaaaa')[m
 [ "$res" = "a" ] || err $LINENO[m
 [m
[32m+[m[32m### FUNCTION TEST ###[m
[32m+[m
[32m+[m[32mres=$($com <<< 'f () { echo a; } ; f')[m
[32m+[m[32m[ "$res" = "a" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'function f () { echo a; } ; f')[m
[32m+[m[32m[ "$res" = "a" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'function f () { A=BBB ; } ; f; echo $A')[m
[32m+[m[32m[ "$res" = "BBB" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'function f () ( A=BBB ) ; f; echo $A')[m
[32m+[m[32m[ "$res" = "" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'function f () { A=BBB ; } ; f | cat; echo $A')[m
[32m+[m[32m[ "$res" = "" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'function f () { tr -d \\n ; } ; seq 3 | f')[m
[32m+[m[32m[ "$res" = "123" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'set a b c ; function f () { echo $2 ; } ; f')[m
[32m+[m[32m[ "$res" = "" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'set a b c ; function f () { echo $2 ; } ; f; echo $2')[m
[32m+[m[32m[ "$res" = "[m
[32m+[m[32mb" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'set a b c ; function f () { set 1 2 3 ; echo $2 ; } ; f; echo $2')[m
[32m+[m[32m[ "$res" = "2[m
[32m+[m[32mb" ] || err $LINENO[m
[32m+[m
 ### NEW LINE ###[m
 [m
 res=$($com <<< 'e\[m
[36m@@ -404,29 +435,29 @@[m [mres=$($com <<< 'A=BBB $(); echo $A')[m
 res=$($com <<< 'A=BBB $(echo); echo $A')[m
 [ "$res" == "BBB" ] || err $LINENO[m
 [m
[31m-#res=$($com <<< 'A=BBB bash -c "echo \$A"')[m
[31m-#[ "$res" == "BBB" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A=BBB B=CCC bash -c "echo \$A \$B"')[m
[31m-#[ "$res" == "BBB CCC" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A=A$(echo BBB)C; echo $A')[m
[31m-#[ "$res" == "ABBBC" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A={a,b}; echo $A')[m
[31m-#[ "$res" == "{a,b}" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A=/*; echo $A | grep -q "*"')[m
[31m-#[ "$?" == "1" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A=/*; echo $A | grep -q "etc"')[m
[31m-#[ "$?" == "0" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A=${ }; echo NG')[m
[31m-#[ "$ref" != "NG" ] || err $LINENO[m
[31m-#[m
[31m-#res=$($com <<< 'A=${ }')[m
[31m-#[ "$?" == 1 ] || err $LINENO[m
[32m+[m[32mres=$($com <<< 'A=BBB bash -c "echo \$A"')[m
[32m+[m[32m[ "$res" == "BBB" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A=BBB B=CCC bash -c "echo \$A \$B"')[m
[32m+[m[32m[ "$res" == "BBB CCC" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A=A$(echo BBB)C; echo $A')[m
[32m+[m[32m[ "$res" == "ABBBC" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A={a,b}; echo $A')[m
[32m+[m[32m[ "$res" == "{a,b}" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A=/*; echo $A | grep -q "*"')[m
[32m+[m[32m[ "$?" == "1" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A=/*; echo $A | grep -q "etc"')[m
[32m+[m[32m[ "$?" == "0" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A=${ }; echo NG')[m
[32m+[m[32m[ "$ref" != "NG" ] || err $LINENO[m
[32m+[m
[32m+[m[32mres=$($com <<< 'A=${ }')[m
[32m+[m[32m[ "$?" == 1 ] || err $LINENO[m
 [m
 # brace[m
 [m
